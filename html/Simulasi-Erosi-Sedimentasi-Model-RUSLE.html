<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Meta Tags for SEO -->
    <title>Pemodelan Numerik dan Simulasi Sedimentasi Waduk Akibat Proses Erosi</title>
    <meta name="description" content="Platform simulasi interaktif untuk pemodelan numerik dan simulasi erosi DAS dan sedimentasi waduk menggunakan model RUSLE. Unggah data poligon Anda sendiri untuk analisis kustom.">
    <meta name="keywords" content="RUSLE, erosi, sedimentasi, Waduk Saguling, simulasi, hidrologi, konservasi tanah, PLTA, GeoJSON, Peta DAS, Analisis DAS, Pemodelan Numerik">
    <meta name="author" content="Mokhamad Abrar, Ratu Avior, Rani A. Royani">

    <!-- Open Graph Meta Tags (for WhatsApp, Facebook, etc.) -->
    <meta property="og:title" content="Pemodelan Numerik dan Simulasi Sedimentasi Waduk">
    <meta property="og:description" content="Pemodelan numerik interaktif untuk sedimentasi waduk akibat erosi, dilengkapi dengan peta DAS yang dinamis.">
    <meta property="og:image" content="https://raw.githubusercontent.com/simcalc/simcalc.github.io/refs/heads/main/img/waduksaguling.webp">
    <meta property="og:url" content="https://simcalc.github.io/">
    <meta property="og:type" content="website">

    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Pemodelan Numerik dan Simulasi Sedimentasi Waduk">
    <meta name="twitter:description" content="Pemodelan numerik interaktif untuk sedimentasi waduk akibat erosi, dilengkapi dengan peta DAS yang dinamis.">
    <meta name="twitter:image" content="https://raw.githubusercontent.com/simcalc/simcalc.github.io/refs/heads/main/img/waduksaguling.webp">

    <link rel="icon" href="https://raw.githubusercontent.com/simcalc/simcalc.github.io/refs/heads/main/img/favicon.ico" type="image/x-icon">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Leaflet.js for Map -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark Industrial Blue-Gray */
            color: #e2e8f0; /* Light Gray Text */
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        
        h1 {
            text-shadow: 2px 2px 8px rgba(0,0,0,0.9);
        }

        .rusle-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #d97706; /* Amber-600 */
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #fefce8; /* yellow-50 */
        }
        .rusle-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #d97706;
            cursor: pointer;
            border-radius: 50%;
             border: 2px solid #fefce8;
        }
        .header-bg {
            background-image: linear-gradient(to bottom, rgba(0,0,0,0.7), rgba(0,0,0,0.4)), url('https://raw.githubusercontent.com/simcalc/simcalc.github.io/refs/heads/main/img/waduksaguling.webp');
            background-size: cover;
            background-position: center;
        }
        .lang-btn {
            background-color: transparent;
            border: 1px solid #d97706; /* Amber-600 */
            color: #d97706;
            border-radius: 5px;
            transition: all 0.2s ease-in-out;
            width: 40px;
        }
        .lang-btn.active, .lang-btn:hover {
            background-color: #d97706;
            color: #1a202c;
            font-weight: bold;
        }
        .help-icon {
            cursor: pointer;
            color: #94a3b8;
            margin-left: 8px;
            display: inline-block;
            border: 1px solid #94a3b8;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            text-align: center;
            line-height: 16px;
            font-size: 12px;
        }
        .help-icon:hover {
            color: #f59e0b;
            border-color: #f59e0b;
        }

        #helpModal {
            transition: opacity 0.3s ease;
        }

        /* Leaflet Dark Theme Adjustments */
        .leaflet-control-attribution, .leaflet-control-attribution a {
            color: #cbd5e1 !important; /* light gray for better readability on satellite */
            text-shadow: 1px 1px 2px #000;
        }
        .leaflet-control-zoom-in, .leaflet-control-zoom-out {
            background-color: #2d3748 !important;
            color: #f59e0b !important;
            border-color: #4a5568 !important;
        }
        .leaflet-popup-content-wrapper, .leaflet-popup-tip {
            background: #2d3748 !important;
            color: #e2e8f0 !important;
            border: 1px solid #4a5568;
        }
        .leaflet-control-layers {
            background: #2d3748 !important;
            border: 1px solid #4a5568 !important;
            color: #e2e8f0 !important;
        }

        /* Responsive adjustments */
        @media (max-width: 1023px) { /* Apply to tablets and below */
            .main-grid {
                grid-template-columns: 1fr;
            }
            .content-stack {
                grid-row: 2; /* Move content below simulation */
            }
        }

        @media (max-width: 767px) { /* Apply to mobile */
            .header-bg {
                position: static;
            }
            #simulationCanvas {
                min-height: 350px;
            }
            .control-panel {
                max-height: none;
            }
        }
    </style>
</head>
<body class="text-gray-200">

    <header class="header-bg text-white p-4 md:p-6 text-center shadow-lg sticky top-0 z-20">
        <div class="flex justify-between items-center container mx-auto">
            <div></div> <!-- Spacer -->
            <h1 class="text-xl md:text-3xl font-bold" data-lang-key="mainTitle">Pemodelan Numerik dan Simulasi Sedimentasi Waduk Akibat Proses Erosi</h1>
            <div class="flex space-x-2">
                <button id="lang-id" class="lang-btn p-1 md:p-2 text-sm">ID</button>
                <button id="lang-en" class="lang-btn p-1 md:p-2 text-sm">EN</button>
            </div>
        </div>
    </header>

    <main class="container mx-auto p-4 md:p-8">
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 md:gap-8 main-grid">
            
            <!-- Kolom Animasi & Peta -->
            <div class="lg:col-span-2 space-y-6 md:space-y-8">
                <div id="canvas-container" class="bg-gray-800 rounded-lg shadow-lg overflow-hidden border border-gray-700">
                    <canvas id="simulationCanvas"></canvas>
                </div>
                 <!-- Peta Lokasi -->
                <section id="map-section" class="flex flex-col">
                    <div class="bg-gray-800 p-4 md:p-8 rounded-lg shadow-lg border border-gray-700 flex-grow flex flex-col">
                        <h3 class="text-xl md:text-2xl font-bold text-amber-400 mb-4 border-b border-gray-600 pb-2" data-lang-key="mapTitle">Peta Lokasi & Estimasi Tingkat Erosi DAS</h3>
                        <div id="map" class="h-96 rounded-lg border border-gray-600 z-10"></div>
                    </div>
                </section>
            </div>

            <!-- Kolom Kontrol dan Data -->
            <div class="lg:col-span-1 space-y-6 md:space-y-8 content-stack">
                <!-- Control Panel -->
                <div class="bg-gray-800 p-4 md:p-6 rounded-lg shadow-lg border border-gray-700 control-panel">
                    <h2 class="text-lg md:text-xl font-bold mb-4 border-b border-gray-600 pb-2 text-amber-400" data-lang-key="simulationControls">Kontrol Simulasi</h2>
                    <div class="grid grid-cols-2 gap-2 mb-6">
                        <button id="startStopBtn" class="bg-gradient-to-b from-amber-400 to-amber-600 hover:from-amber-500 hover:to-amber-700 border border-amber-700 text-gray-900 font-bold py-2 px-4 rounded transition-all duration-200 text-sm md:text-base" data-lang-key="startBtn">Mulai</button>
                        <button id="resetBtn" class="bg-gradient-to-b from-gray-600 to-gray-800 hover:from-gray-700 hover:to-gray-900 border border-gray-500 text-white font-bold py-2 px-4 rounded transition-all duration-200 text-sm md:text-base" data-lang-key="resetBtn">Reset</button>
                    </div>

                    <!-- Data Kustom -->
                     <div class="space-y-3 mb-6 p-4 border border-dashed border-gray-600 rounded-lg">
                        <h4 class="text-base md:text-lg font-bold text-amber-400" data-lang-key="customDataTitle">Data DAS Kustom</h4>
                        <div>
                            <label for="csvFileInput" class="block text-sm font-medium text-gray-400" data-lang-key="uploadLabel">Unggah Poligon DAS (.csv)</label>
                            <input type="file" id="csvFileInput" accept=".csv" class="mt-1 block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-amber-500 file:text-amber-900 hover:file:bg-amber-600">
                             <p class="text-xs text-gray-500 mt-1" data-lang-key="csvFormat">Format: 2 kolom (latitude, longitude), tanpa header.</p>
                        </div>
                    </div>


                    <!-- Parameter Input Manual -->
                    <h3 class="text-base md:text-lg font-bold mb-3 text-amber-400 flex items-center" data-lang-key="reservoirParams">Parameter Dasar Waduk <span class="help-icon" data-help-topic="reservoirParams">?</span></h3>
                     <div class="space-y-3 mb-6">
                        <div>
                            <label for="annualRainfall" class="block text-sm font-medium text-gray-400" data-lang-key="annualRainfall">Curah Hujan Tahunan (mm)</label>
                            <input type="number" id="annualRainfall" value="3175" class="mt-1 block w-full rounded-md bg-gray-700 border-gray-600 text-gray-200 shadow-sm focus:border-amber-500 focus:ring-amber-500 sm:text-sm">
                        </div>
                        <div>
                            <label for="watershedArea" class="block text-sm font-medium text-gray-400" data-lang-key="watershedArea">Luas DAS (Ha)</label>
                            <input type="number" id="watershedArea" value="55700" class="mt-1 block w-full rounded-md bg-gray-700 border-gray-600 text-gray-200 shadow-sm focus:border-amber-500 focus:ring-amber-500 sm:text-sm">
                        </div>
                        <div>
                            <label for="reservoirVolume" class="block text-sm font-medium text-gray-400" data-lang-key="sedimentVolume">Total Volume Tampungan Sedimen (Juta m³)</label>
                            <input type="number" id="reservoirVolume" value="40.3" class="mt-1 block w-full rounded-md bg-gray-700 border-gray-600 text-gray-200 shadow-sm focus:border-amber-500 focus:ring-amber-500 sm:text-sm">
                        </div>
                    </div>
                    
                    <!-- Parameter RUSLE -->
                    <h3 class="text-base md:text-lg font-bold mb-3 text-amber-400 flex items-center" data-lang-key="rusleParams">Parameter RUSLE <span class="help-icon" data-help-topic="rusleParams">?</span></h3>
                    <div id="rusle-controls" class="space-y-4">
                        <!-- Sliders will be dynamically inserted here -->
                    </div>
                </div>

                <!-- Data Panel -->
                <div class="bg-gray-800 p-4 md:p-6 rounded-lg shadow-lg border border-gray-700">
                    <h2 class="text-lg md:text-xl font-bold mb-4 border-b border-gray-600 pb-2 text-amber-400" data-lang-key="simulationData">Data Hasil Simulasi</h2>
                    <div id="simulationData" class="space-y-2 text-sm">
                        <p><strong class="text-gray-100" data-lang-key="simDay">Hari Simulasi:</strong> <span id="dayCount" class="text-gray-300">0</span></p>
                        <p><strong class="text-gray-100" data-lang-key="estimatedLifespan">Perkiraan Umur Waduk:</strong> <span id="estimatedLife" class="text-amber-300">Menghitung...</span> tahun</p>
                        <p><strong class="text-gray-100" data-lang-key="dailyErosion">Erosi Harian (ton):</strong> <span id="dailyErosion" class="text-gray-300">0.00</span></p>
                        <p><strong class="text-gray-100" data-lang-key="totalErosion">Total Erosi (ton):</strong> <span id="totalErosion" class="text-gray-300">0.00</span></p>
                        <p><strong class="text-gray-100" data-lang-key="soilSaturation">Kejenuhan Tanah:</strong> <span id="soilSaturation" class="text-gray-300">0</span>%</p>
                        <p><strong class="text-gray-100" data-lang-key="basinSedimentation">Sedimentasi Cekungan:</strong> <span id="sedimentationLevel" class="text-gray-300">0.00</span>%</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bagian Penjelasan Tambahan -->
        <div class="mt-8 space-y-6 md:space-y-8">
            <section id="rusle-explanation">
                <div class="bg-gray-800 p-4 md:p-8 rounded-lg shadow-lg border border-gray-700">
                    <h3 class="text-xl md:text-2xl font-bold text-amber-400 mb-4 border-b border-gray-600 pb-2" data-lang-key="rusleTheoryTitle">Landasan Teori: Model RUSLE</h3>
                    <p class="text-gray-300 mb-4" data-lang-key="rusleTheoryDesc">
                        The Revised Universal Soil Loss Equation (RUSLE) adalah model empiris yang digunakan secara luas untuk memprediksi erosi tanah jangka panjang rata-rata oleh air. Model ini merupakan pengembangan dari USLE (Universal Soil Loss Equation) dengan penyempurnaan pada beberapa faktornya [1]. Persamaan RUSLE dihitung sebagai:
                    </p>
                    <div class="bg-gray-900 p-4 rounded-lg text-center my-4 border border-gray-700">
                        <code class="text-lg font-mono text-amber-300">A = R × K × LS × C × P</code>
                    </div>
                    <ul class="list-disc list-inside space-y-2 text-gray-300">
                        <li><b class="text-amber-400">A</b> = <span data-lang-key="rusleFactorA">Rata-rata Erosi Tanah Tahunan (ton/hektar/tahun).</span></li>
                        <li><b class="text-amber-400">R</b> = <span data-lang-key="rusleFactorR">Faktor Erosivitas Curah Hujan, yang mengukur energi kinetik dan intensitas hujan [2].</span></li>
                        <li><b class="text-amber-400">K</b> = <span data-lang-key="rusleFactorK">Faktor Erodibilitas Tanah, yang mengukur kerentanan partikel tanah terhadap erosi.</span></li>
                        <li><b class="text-amber-400">LS</b> = <span data-lang-key="rusleFactorLS">Faktor Panjang dan Kemiringan Lereng, yang merepresentasikan pengaruh topografi.</span></li>
                        <li><b class="text-amber-400">C</b> = <span data-lang-key="rusleFactorC">Faktor Pengelolaan Tanaman dan Vegetasi, yang menunjukkan pengaruh tutupan lahan.</span></li>
                        <li><b class="text-amber-400">P</b> = <span data-lang-key="rusleFactorP">Faktor Tindakan Konservasi, yang merepresentasikan praktik pengelolaan lahan untuk mengendalikan erosi [3].</span></li>
                    </ul>
                </div>
            </section>
            
            <section id="case-study">
                <div class="bg-gray-800 p-4 md:p-8 rounded-lg shadow-lg border border-gray-700">
                     <h3 class="text-xl md:text-2xl font-bold text-amber-400 mb-4 border-b border-gray-600 pb-2" data-lang-key="caseStudyTitle">Studi Kasus: Waduk Saguling</h3>
                    <p class="text-gray-300 mb-4" data-lang-key="caseStudyP1">
                        Waduk Saguling, yang berlokasi di Jawa Barat, merupakan salah satu infrastruktur vital untuk Pembangkit Listrik Tenaga Air (PLTA). Namun, seperti banyak waduk lainnya, Saguling menghadapi ancaman serius dari laju sedimentasi yang tinggi akibat erosi di Daerah Aliran Sungai (DAS) Citarum Hulu. Tingginya laju erosi ini disebabkan oleh kombinasi faktor alam (curah hujan tinggi, tanah rentan) dan aktivitas manusia (perubahan tata guna lahan, praktik pertanian yang kurang tepat) [4].
                    </p>
                    <p class="text-gray-300" data-lang-key="caseStudyP2">
                        Penelitian yang dilakukan oleh Rani Annisa Royani (2014) menggunakan model RUSLE untuk menganalisis laju erosi dan sedimentasi di DAS Waduk Saguling. Studi ini mengintegrasikan data curah hujan, jenis tanah, topografi, dan tata guna lahan untuk memetakan area-area kritis yang menjadi sumber utama erosi. Hasilnya digunakan untuk mengestimasi laju sedimentasi tahunan dan memprediksi sisa umur fungsional waduk. Simulasi ini menggunakan parameter dan temuan dari penelitian tersebut sebagai dasar untuk memvisualisasikan proses dan dampak erosi secara dinamis [4].
                    </p>
                </div>
            </section>

            <!-- Metode Penelitian Section -->
            <section id="methodology">
                <div class="bg-gray-800 p-4 md:p-8 rounded-lg shadow-lg border border-gray-700">
                    <h3 class="text-xl md:text-2xl font-bold text-amber-400 mb-4 border-b border-gray-600 pb-2" data-lang-key="methodologyTitle">Metode Penelitian</h3>
                    <p class="text-gray-300 mb-4" data-lang-key="methodologyDesc">
                        Metodologi yang diadopsi dalam penelitian Rani Annisa Royani untuk menganalisis erosi dan sedimentasi di DAS Waduk Saguling merupakan pendekatan kuantitatif yang sistematis dengan menggunakan model RUSLE. Pendekatan ini, yang menjadi dasar bagi simulasi yang Anda lihat, memiliki tahapan sebagai berikut [4]:
                    </p>
                    <ol class="list-decimal list-inside space-y-3 text-gray-300">
                        <li>
                            <strong class="text-gray-100" data-lang-key="methodStep1">Pengumpulan Data Sekunder:</strong>
                            <span data-lang-key="methodStep1Desc">Tahap awal melibatkan pengumpulan data-data krusial yang menjadi input bagi setiap faktor dalam model RUSLE. Data ini meliputi:</span>
                            <ul class="list-disc list-inside ml-5 mt-2 space-y-1">
                                <li data-lang-key="methodStep1_1"><strong>Data Curah Hujan:</strong> Data historis dari beberapa stasiun cuaca di sekitar DAS untuk menghitung nilai erosivitas hujan (Faktor R).</li>
                                <li data-lang-key="methodStep1_2"><strong>Data Tanah:</strong> Peta jenis tanah untuk menentukan nilai erodibilitas tanah (Faktor K).</li>
                                <li data-lang-key="methodStep1_3"><strong>Data Topografi:</strong> Peta kontur atau data Digital Elevation Model (DEM) untuk menurunkan faktor panjang dan kemiringan lereng (Faktor LS).</li>
                                <li data-lang-key="methodStep1_4"><strong>Data Penggunaan Lahan:</strong> Peta tutupan lahan untuk menentukan faktor pengelolaan tanaman (Faktor C).</li>
                                <li data-lang-key="methodStep1_5"><strong>Data Konservasi:</strong> Informasi mengenai praktik konservasi tanah dan air yang diterapkan di area tersebut (Faktor P).</li>
                            </ul>
                        </li>
                        <li>
                            <strong class="text-gray-100" data-lang-key="methodStep2">Analisis Spasial dan Perhitungan Faktor:</strong>
                             <span data-lang-key="methodStep2Desc">Setiap data diolah menggunakan perangkat lunak Sistem Informasi Geografis (SIG) untuk menghitung nilai masing-masing faktor RUSLE secara spasial (per unit lahan) di seluruh area DAS.</span>
                        </li>
                        <li>
                            <strong class="text-gray-100" data-lang-key="methodStep3">Estimasi Laju Erosi:</strong>
                            <span data-lang-key="methodStep3Desc">Nilai dari kelima faktor tersebut (R, K, LS, C, dan P) dikalikan sesuai dengan persamaan RUSLE (A = R × K × LS × C × P) untuk mendapatkan laju erosi potensial tahunan (A) dalam satuan ton/ha/tahun untuk setiap unit lahan.</span>
                        </li>
                        <li>
                            <strong class="text-gray-100" data-lang-key="methodStep4">Perhitungan Laju Sedimentasi:</strong>
                            <span data-lang-key="methodStep4Desc">Laju erosi yang didapat kemudian dikonversi menjadi laju sedimen yang masuk ke waduk (Sediment Yield) dengan mengalikannya dengan <em>Sediment Delivery Ratio</em> (SDR). SDR adalah rasio sedimen yang sampai ke muara sungai terhadap total erosi yang terjadi di DAS.</span>
                        </li>
                        <li>
                            <strong class="text-gray-100" data-lang-key="methodStep5">Analisis Umur Waduk:</strong>
                            <span data-lang-key="methodStep5Desc">Dengan membandingkan laju sedimentasi tahunan dengan total kapasitas tampungan sedimen waduk, penelitian ini mengestimasi sisa umur fungsional Waduk Saguling hingga tampungan tersebut penuh oleh sedimen.</span>
                        </li>
                    </ol>
                </div>
            </section>

            <section id="mitigation">
                <div class="bg-gray-800 p-4 md:p-8 rounded-lg shadow-lg border border-gray-700">
                    <h3 class="text-xl md:text-2xl font-bold text-amber-400 mb-4 border-b border-gray-600 pb-2" data-lang-key="mitigationTitle">Rekomendasi Mitigasi</h3>
                    <div class="md:flex md:space-x-8 items-center">
                        <div class="md:w-2/3">
                            <p class="text-gray-300 mb-4" data-lang-key="mitigationDesc">
                                Berdasarkan simulasi dan analisis, prediksi umur waduk sangat sensitif terhadap Faktor C (Pengelolaan Tanaman) dan Faktor P (Tindakan Konservasi). Ini menunjukkan bahwa tindakan mitigasi di hulu, seperti yang dijelaskan dalam berbagai literatur konservasi tanah, adalah kunci untuk memperjang umur Waduk Saguling [3].
                            </p>
                            <h4 class="text-lg font-bold text-gray-100 mt-4 mb-2" data-lang-key="mitigationHuluTitle">Rekomendasi Mitigasi Hulu:</h4>
                            <ul class="list-disc list-inside space-y-2 text-gray-300">
                                <li data-lang-key="mitigationItem1"><b>Reboisasi dan Agroforestri:</b> Menanam kembali vegetasi di lahan kritis untuk meningkatkan tutupan lahan (menurunkan Faktor C).</li>
                                <li data-lang-key="mitigationItem2"><b>Pembuatan Terasering:</b> Membangun teras pada lahan miring untuk memperlambat aliran permukaan dan mengurangi erosi (meningkatkan Faktor P).</li>
                                <li data-lang-key="mitigationItem3"><b>Pola Tanam Kontur:</b> Menanam sejajar dengan garis kontur untuk menahan air dan tanah.</li>
                                <li data-lang-key="mitigationItem4"><b>Penyuluhan kepada Masyarakat:</b> Edukasi mengenai praktik pertanian berkelanjutan untuk mengurangi erosi tanah.</li>
                            </ul>
                        </div>
                        <div class="md:w-1/3 mt-6 md:mt-0">
                             <figure>
                                <img src="https://raw.githubusercontent.com/simcalc/simcalc.github.io/refs/heads/main/img/Saguling.webp" alt="Ilustrasi tindakan konservasi di DAS Waduk Saguling" class="rounded-lg shadow-md mx-auto">
                                <figcaption class="text-center text-sm text-gray-500 mt-2" data-lang-key="mitigationFigcaption">Tindakan konservasi di hulu adalah kunci keberlanjutan waduk.</figcaption>
                            </figure>
                        </div>
                    </div>
                </div>
            </section>

            <section id="references">
                 <div class="bg-gray-800 p-4 md:p-8 rounded-lg shadow-lg border border-gray-700">
                    <h3 class="text-xl md:text-2xl font-bold text-amber-400 mb-4 border-b border-gray-600 pb-2" data-lang-key="referencesTitle">Daftar Pustaka</h3>
                    <ol class="list-decimal list-inside space-y-2 text-gray-400 text-sm">
                        <li>Renard, K. G., Foster, G. R., Weesies, G. A., McCool, D. K., & Yoder, D. C. (1997). <em>Predicting soil erosion by water: a guide to conservation planning with the Revised Universal Soil Loss Equation (RUSLE)</em>. U.S. Department of Agriculture, Agriculture Handbook No. 703. <a href="https://www.ars.usda.gov/ARSUserFiles/20902500/DonMcCool/EstimatingWaterErosionandSedimentYieldwithGis,Rusle,andSedd.pdf" target="_blank" rel="noopener noreferrer" class="text-amber-500 hover:underline">[Link]</a></li>
                        <li>Wischmeier, W. H., & Smith, D. D. (1978). <em>Predicting rainfall erosion losses: a guide to conservation planning</em>. U.S. Department of Agriculture, Agriculture Handbook No. 537. <a href="https://www.ars.usda.gov/ARSUserFiles/60600505/RUSLE/AH_537%20Predicting%20Rainfall%20Soil%20Losses.pdf" target="_blank" rel="noopener noreferrer" class="text-amber-500 hover:underline">[Link]</a></li>
                        <li>Morgan, R. P. C. (2005). <em>Soil Erosion and Conservation</em>. Blackwell Publishing. <a href="https://svgaos.nl/wp-content/uploads/2017/02/Morgan_2005_Soil_Erosion_and_Conservation.pdf" target="_blank" rel="noopener noreferrer" class="text-amber-500 hover:underline">[Link]</a></li>
                        <li>Royani, R. A. (2014). <em>Analisis Laju Erosi, Sedimentasi, dan Umur Waduk (Studi Kasus Waduk Saguling Jawa Barat)</em>. Tesis, Institut Teknologi Bandung. <a href="https://digilib.it.id/gdl/view/68525/" target="_blank" rel="noopener noreferrer" class="text-amber-500 hover:underline">[Link]</a></li>
                    </ol>
                </div>
            </section>
        </div>
    </main>

    <footer class="bg-black text-white text-center p-6 mt-8">
        <div class="space-y-2 text-sm">
             <div data-lang-key="footerDesigned">Designed by <a href="https://id.linkedin.com/in/mokhamadabrar" target="_blank" rel="noopener" class="text-amber-400 hover:underline">Mokhamad Abrar</a></div>
             <div data-lang-key="footerReviewed">Reviewed by <a href="https://id.linkedin.com/in/avior-qhse" target="_blank" rel="noopener" class="text-amber-400 hover:underline">Ratu Avior, MSc.</a> and <a href="https://id.linkedin.com/in/raniannisaroyani" target="_blank" rel="noopener noreferrer" class="text-amber-400 hover:underline">Ir. Rani A. Royani, MSc.</a></div>
             <div data-lang-key="footerDate">Sustainable Apps Development @ Aug 2025</div>
        </div>
    </footer>

    <!-- Help Modal -->
    <div id="helpModal" class="fixed inset-0 bg-black bg-opacity-70 z-50 hidden items-center justify-center p-4" style="transition: opacity 0.3s ease;">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 border border-gray-700 w-full max-w-lg relative">
            <button id="closeHelpModal" class="absolute top-3 right-3 text-gray-400 hover:text-white">&times;</button>
            <h3 id="helpModalTitle" class="text-xl font-bold text-amber-400 mb-4"></h3>
            <div id="helpModalContent" class="text-gray-300 text-sm space-y-3"></div>
        </div>
    </div>


    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        
        // Buttons and Data Displays
        const startStopBtn = document.getElementById('startStopBtn');
        const resetBtn = document.getElementById('resetBtn');
        const dayCountEl = document.getElementById('dayCount');
        const dailyErosionEl = document.getElementById('dailyErosion');
        const totalErosionEl = document.getElementById('totalErosion');
        const soilSaturationEl = document.getElementById('soilSaturation');
        const sedimentationLevelEl = document.getElementById('sedimentationLevel');
        const estimatedLifeEl = document.getElementById('estimatedLife');
        
        // Manual Input Fields
        const annualRainfallInput = document.getElementById('annualRainfall');
        const watershedAreaInput = document.getElementById('watershedArea');
        const reservoirVolumeInput = document.getElementById('reservoirVolume');
        const csvFileInput = document.getElementById('csvFileInput');
        
        // Language Buttons
        const langIdBtn = document.getElementById('lang-id');
        const langEnBtn = document.getElementById('lang-en');

        // Help Modal Elements
        const helpModal = document.getElementById('helpModal');
        const helpModalTitle = document.getElementById('helpModalTitle');
        const helpModalContent = document.getElementById('helpModalContent');
        const closeHelpModalBtn = document.getElementById('closeHelpModal');


        let isRunning = false;
        let animationFrameId;
        let simulationLog = [];
        let map;
        let watershedLayer;
        let assessmentMarker;
        let currentWatershedGeoJson; 

        // --- Simulation Parameters ---
        let day = 0;
        let soilSaturation = 0; // 0 to 100
        let totalErosion = 0; // in tons
        let totalSediment = 0; // in cubic meters

        // Weather cycle
        let daysOfRain = 0;
        let daysOfSun = 0;
        const maxRainDays = 5;
        const maxSunDays = 3;
        let isRaining = true;

        // Particles
        let rainParticles = [];
        let runoffParticles = [];
        let evaporationParticles = [];
        let splashParticles = [];
        let clouds = [];
        let lightning = { alpha: 0, path: [] };

        // --- Language & Translations ---
        let currentLanguage = 'id';
        const translations = {
            en: {
                mainTitle: "Numerical Modeling and Simulation of Reservoir Sedimentation Due to Erosion",
                simulationControls: "Simulation Controls",
                startBtn: "Start", continueBtn: "Start", pauseBtn: "Pause", resetBtn: "Reset", exportBtn: "Export Data (CSV)",
                customDataTitle: "Custom Watershed Data",
                uploadLabel: "Upload Watershed Polygon (.csv)",
                csvFormat: "Format: 2 columns (latitude, longitude), no header.",
                reservoirParams: "Basic Reservoir Parameters",
                annualRainfall: "Annual Rainfall (mm)", watershedArea: "Watershed Area (Ha)", sedimentVolume: "Total Sediment Storage Volume (Million m³)",
                rusleParams: "RUSLE Parameters",
                simulationData: "Simulation Results Data",
                simDay: "Simulation Day:", estimatedLifespan: "Estimated Reservoir Lifespan:", dailyErosion: "Daily Erosion (tons):",
                totalErosion: "Total Erosion (tons):", soilSaturation: "Soil Saturation:", basinSedimentation: "Basin Sedimentation:",
                rusleTheoryTitle: "Theoretical Basis: RUSLE Model",
                rusleTheoryDesc: "The Revised Universal Soil Loss Equation (RUSLE) is a widely used empirical model to predict the long-term average annual rate of erosion by water. This model is an evolution of the USLE (Universal Soil Loss Equation) with improvements to several of its factors [1]. The RUSLE equation is calculated as:",
                rusleFactorA: "Average Annual Soil Loss (tons/hectare/year).",
                rusleFactorR: "Rainfall-Runoff Erosivity Factor, which measures the kinetic energy and intensity of rain [2].",
                rusleFactorK: "Soil Erodibility Factor, which measures the susceptibility of soil particles to erosion.",
                rusleFactorLS: "Slope Length and Steepness Factor, which represents the effect of topography.",
                rusleFactorC: "Cover-Management Factor, which reflects the effect of land cover.",
                rusleFactorP: "Support Practice Factor, which represents land management practices to control erosion [3].",
                caseStudyTitle: "Case Study: Saguling Reservoir",
                caseStudyP1: "Saguling Reservoir, located in West Java, is a vital infrastructure for a Hydroelectric Power Plant (PLTA). However, like many other reservoirs, Saguling faces a serious threat from high sedimentation rates due to erosion in the Upper Citarum Watershed. This high erosion rate is caused by a combination of natural factors (high rainfall, vulnerable soil) and human activities (land-use change, improper agricultural practices) [4].",
                caseStudyP2: "The research conducted by Rani Annisa Royani (2014) used the RUSLE model to analyze the rate of erosion and sedimentation in the Saguling Reservoir Watershed. This study integrated data on rainfall, soil type, topography, and land use to map critical areas that are the main sources of erosion. The results were used to estimate the annual sedimentation rate and predict the remaining functional life of the reservoir. This simulation uses parameters and findings from that research as a basis for dynamically visualizing the process and impact of erosion [4].",
                methodologyTitle: "Research Methodology",
                methodologyDesc: "The methodology adopted in Rani Annisa Royani's research to analyze erosion and sedimentation in the Saguling Reservoir Watershed is a systematic quantitative approach using the RUSLE model. This approach, which forms the basis for the simulation you see, has the following stages [4]:",
                methodStep1: "Secondary Data Collection:", methodStep1Desc: "The initial stage involves collecting crucial data that serve as input for each factor in the RUSLE model. This data includes:",
                methodStep1_1: "<strong>Rainfall Data:</strong> Historical data from several weather stations around the watershed to calculate rainfall erosivity (R Factor).",
                methodStep1_2: "<strong>Soil Data:</strong> Soil type maps to determine soil erodibility (K Factor).",
                methodStep1_3: "<strong>Topography Data:</strong> Contour maps or Digital Elevation Model (DEM) data to derive the slope length and steepness factor (LS Factor).",
                methodStep1_4: "<strong>Land Use Data:</strong> Land cover maps to determine the cover-management factor (C Factor).",
                methodStep1_5: "<strong>Conservation Data:</strong> Information on soil and water conservation practices implemented in the area (P Factor).",
                methodStep2: "Spatial Analysis and Factor Calculation:", methodStep2Desc: "Each dataset is processed using Geographic Information System (GIS) software to spatially calculate the value of each RUSLE factor (per land unit) across the entire watershed area.",
                methodStep3: "Erosion Rate Estimation:", methodStep3Desc: "The values of the five factors (R, K, LS, C, and P) are multiplied according to the RUSLE equation (A = R × K × LS × C × P) to obtain the potential annual erosion rate (A) in tons/ha/year for each land unit.",
                methodStep4: "Sedimentation Rate Calculation:", methodStep4Desc: "The resulting erosion rate is then converted into the sediment yield entering the reservoir by multiplying it by the <em>Sediment Delivery Ratio</em> (SDR). SDR is the ratio of sediment that reaches the river mouth to the total erosion occurring in the watershed.",
                methodStep5: "Reservoir Lifespan Analysis:", methodStep5Desc: "By comparing the annual sedimentation rate with the total sediment storage capacity of the reservoir, the research estimates the remaining functional life of Saguling Reservoir until the storage is filled with sediment.",
                mitigationTitle: "Mitigation Recommendations",
                mitigationDesc: "Based on simulation and analysis, the predicted reservoir lifespan is highly sensitive to the C Factor (Cover Management) and P Factor (Support Practices). This indicates that upstream mitigation measures, as described in various soil conservation literature, are key to extending the life of Saguling Reservoir [3].",
                mitigationHuluTitle: "Upstream Mitigation Recommendations:",
                mitigationItem1: "<b>Reforestation and Agroforestry:</b> Replanting vegetation on critical lands to increase land cover (lowering the C Factor).",
                mitigationItem2: "<b>Terracing:</b> Building terraces on sloping land to slow surface runoff and reduce erosion (improving the P Factor).",
                mitigationItem3: "<b>Contour Farming:</b> Planting parallel to contour lines to retain water and soil.",
                mitigationItem4: "<b>Community Outreach:</b> Educating the community on sustainable agricultural practices to reduce soil erosion.",
                mitigationFigcaption: "Upstream conservation measures are key to reservoir sustainability.",
                referencesTitle: "References",
                footerDesigned: 'Designed by <a href="https://id.linkedin.com/in/mokhamadabrar" target="_blank" rel="noopener" class="text-amber-400 hover:underline">Mokhamad Abrar</a>',
                footerReviewed: 'Reviewed by <a href="https://id.linkedin.com/in/avior-qhse" target="_blank" rel="noopener" class="text-amber-400 hover:underline">Ratu Avior, MSc.</a> and <a href="https://id.linkedin.com/in/raniannisaroyani" target="_blank" rel="noopener noreferrer" class="text-amber-400 hover:underline">Ir. Rani A. Royani, MSc.</a>',
                footerDate: "Sustainable Apps Development @ Aug 2025",
                alertFull: "Simulation stopped: Sedimentation basin is full.",
                mapTitle: "Location Map & Watershed Erosion Estimation",
                helpReservoirTitle: "Help: Basic Reservoir Parameters",
                helpReservoirContent: `<p>These parameters define the fundamental characteristics of the reservoir and its watershed, which are used as the basis for calculating erosion and lifespan.</p>
                                       <ul>
                                           <li><b>Annual Rainfall:</b> Directly influences the Rainfall Erosivity Factor (R). Higher rainfall generally leads to a higher potential for erosion.</li>
                                           <li><b>Watershed Area (DAS):</b> The total land area that drains water and sediment into the reservoir. A larger area means more potential for total erosion.</li>
                                           <li><b>Total Sediment Storage Volume:</b> The maximum capacity of the reservoir to hold sediment. This value, combined with the annual sedimentation rate, determines the reservoir's lifespan.</li>
                                       </ul>`,
                helpRusleTitle: "Help: RUSLE Parameters",
                helpRusleContent: `<p>These parameters are the core of the RUSLE model. Adjust them to simulate different scenarios of land management and conservation.</p>
                                   <ul>
                                       <li><b>R (Rainfall Erosivity):</b> Automatically calculated from Annual Rainfall. It represents the potential of rain to cause erosion.</li>
                                       <li><b>K (Soil Erodibility):</b> The soil's inherent resistance to erosion. Clay soils have low K values, while silty soils have high K values.</li>
                                       <li><b>LS (Slope Length & Steepness):</b> Represents topography. Longer and steeper slopes result in higher erosion rates.</li>
                                       <li><b>C (Cover-Management):</b> Represents land cover. Low values indicate dense vegetation (like forests), while high values indicate bare land. <b>This is a key factor for mitigation.</b></li>
                                       <li><b>P (Support Practice):</b> Represents conservation practices like terracing or contour farming. A value of 1 means no practices, while lower values indicate effective conservation. <b>This is a key factor for mitigation.</b></li>
                                   </ul>`
            },
            id: {
                mainTitle: "Pemodelan Numerik dan Simulasi Sedimentasi Waduk Akibat Proses Erosi",
                simulationControls: "Kontrol Simulasi",
                startBtn: "Mulai", continueBtn: "Mulai", pauseBtn: "Jeda", resetBtn: "Reset", exportBtn: "Ekspor Data (CSV)",
                customDataTitle: "Data DAS Kustom",
                uploadLabel: "Unggah Poligon DAS (.csv)",
                csvFormat: "Format: 2 kolom (latitude, longitude), tanpa header.",
                reservoirParams: "Parameter Dasar Waduk",
                annualRainfall: "Curah Hujan Tahunan (mm)", watershedArea: "Luas DAS (Ha)", sedimentVolume: "Total Volume Tampungan Sedimen (Juta m³)",
                rusleParams: "Parameter RUSLE",
                simulationData: "Data Hasil Simulasi",
                simDay: "Hari Simulasi:", estimatedLifespan: "Perkiraan Umur Waduk:", dailyErosion: "Erosi Harian (ton):",
                totalErosion: "Total Erosi (ton):", soilSaturation: "Kejenuhan Tanah:", basinSedimentation: "Sedimentasi Cekungan:",
                rusleTheoryTitle: "Landasan Teori: Model RUSLE",
                rusleTheoryDesc: "The Revised Universal Soil Loss Equation (RUSLE) adalah model empiris yang digunakan secara luas untuk memprediksi erosi tanah jangka panjang rata-rata oleh air. Model ini merupakan pengembangan dari USLE (Universal Soil Loss Equation) dengan penyempurnaan pada beberapa faktornya [1]. Persamaan RUSLE dihitung sebagai:",
                rusleFactorA: "Rata-rata Erosi Tanah Tahunan (ton/hektar/tahun).",
                rusleFactorR: "Faktor Erosivitas Curah Hujan, yang mengukur energi kinetik dan intensitas hujan [2].",
                rusleFactorK: "Faktor Erodibilitas Tanah, yang mengukur kerentanan partikel tanah terhadap erosi.",
                rusleFactorLS: "Faktor Panjang dan Kemiringan Lereng, yang merepresentasikan pengaruh topografi.",
                rusleFactorC: "Faktor Pengelolaan Tanaman dan Vegetasi, yang menunjukkan pengaruh tutupan lahan.",
                rusleFactorP: "Faktor Tindakan Konservasi, yang merepresentasikan praktik pengelolaan lahan untuk mengendalikan erosi [3].",
                caseStudyTitle: "Studi Kasus: Waduk Saguling",
                caseStudyP1: "Waduk Saguling, yang berlokasi di Jawa Barat, merupakan salah satu infrastruktur vital untuk Pembangkit Listrik Tenaga Air (PLTA). Namun, seperti banyak waduk lainnya, Saguling menghadapi ancaman serius dari laju sedimentasi yang tinggi akibat erosi di Daerah Aliran Sungai (DAS) Citarum Hulu. Tingginya laju erosi ini disebabkan oleh kombinasi faktor alam (curah hujan tinggi, tanah rentan) dan aktivitas manusia (perubahan tata guna lahan, praktik pertanian yang kurang tepat) [4].",
                caseStudyP2: "Penelitian yang dilakukan oleh Rani Annisa Royani (2014) menggunakan model RUSLE untuk menganalisis laju erosi dan sedimentasi di DAS Waduk Saguling. Studi ini mengintegrasikan data curah hujan, jenis tanah, topografi, dan tata guna lahan untuk memetakan area-area kritis yang menjadi sumber utama erosi. Hasilnya digunakan untuk mengestimasi laju sedimentasi tahunan dan memprediksi sisa umur fungsional waduk. Simulasi ini menggunakan parameter dan temuan dari penelitian tersebut sebagai dasar untuk memvisualisasikan proses dan dampak erosi secara dinamis [4].",
                methodologyTitle: "Metode Penelitian",
                methodologyDesc: "Metodologi yang diadopsi dalam penelitian Rani Annisa Royani untuk menganalisis erosi dan sedimentasi di DAS Waduk Saguling merupakan pendekatan kuantitatif yang sistematis dengan menggunakan model RUSLE. Pendekatan ini, yang menjadi dasar bagi simulasi yang Anda lihat, memiliki tahapan sebagai berikut [4]:",
                methodStep1: "Pengumpulan Data Sekunder:", methodStep1Desc: "Tahap awal melibatkan pengumpulan data-data krusial yang menjadi input bagi setiap faktor dalam model RUSLE. Data ini meliputi:",
                methodStep1_1: "<strong>Data Curah Hujan:</strong> Data historis dari beberapa stasiun cuaca di sekitar DAS untuk menghitung nilai erosivitas hujan (Faktor R).",
                methodStep1_2: "<strong>Data Tanah:</strong> Peta jenis tanah untuk menentukan nilai erodibilitas tanah (Faktor K).",
                methodStep1_3: "<strong>Data Topografi:</strong> Peta kontur atau data Digital Elevation Model (DEM) untuk menurunkan faktor panjang dan kemiringan lereng (Faktor LS).",
                methodStep1_4: "<strong>Data Penggunaan Lahan:</strong> Peta tutupan lahan untuk menentukan faktor pengelolaan tanaman (Faktor C).",
                methodStep1_5: "<strong>Data Konservasi:</strong> Informasi mengenai praktik konservasi tanah dan air yang diterapkan di area tersebut (Faktor P).",
                methodStep2: "Analisis Spasial dan Perhitungan Faktor:", methodStep2Desc: "Setiap data diolah menggunakan perangkat lunak Sistem Informasi Geografis (SIG) untuk menghitung nilai masing-masing faktor RUSLE secara spasial (per unit lahan) di seluruh area DAS.",
                methodStep3: "Estimasi Laju Erosi:", methodStep3Desc: "Nilai dari kelima faktor tersebut (R, K, LS, C, dan P) dikalikan sesuai dengan persamaan RUSLE (A = R × K × LS × C × P) untuk mendapatkan laju erosi potensial tahunan (A) dalam satuan ton/ha/tahun untuk setiap unit lahan.",
                methodStep4: "Perhitungan Laju Sedimentasi:", methodStep4Desc: "Laju erosi yang didapat kemudian dikonversi menjadi laju sedimen yang masuk ke waduk (Sediment Yield) dengan mengalikannya dengan <em>Sediment Delivery Ratio</em> (SDR). SDR adalah rasio sedimen yang sampai ke muara sungai terhadap total erosi yang terjadi di DAS.",
                methodStep5: "Analisis Umur Waduk:", methodStep5Desc: "Dengan membandingkan laju sedimentasi tahunan dengan total kapasitas tampungan sedimen waduk, penelitian ini mengestimasi sisa umur fungsional Waduk Saguling hingga tampungan tersebut penuh oleh sedimen.",
                mitigationTitle: "Rekomendasi Mitigasi",
                mitigationDesc: "Berdasarkan simulasi dan analisis, prediksi umur waduk sangat sensitif terhadap Faktor C (Pengelolaan Tanaman) dan Faktor P (Tindakan Konservasi). Ini menunjukkan bahwa tindakan mitigasi di hulu, seperti yang dijelaskan dalam berbagai literatur konservasi tanah, adalah kunci untuk memperpanjang umur Waduk Saguling [3].",
                mitigationHuluTitle: "Rekomendasi Mitigasi Hulu:",
                mitigationItem1: "<b>Reboisasi dan Agroforestri:</b> Menanam kembali vegetasi di lahan kritis untuk meningkatkan tutupan lahan (menurunkan Faktor C).",
                mitigationItem2: "<b>Pembuatan Terasering:</b> Membangun teras pada lahan miring untuk memperlambat aliran permukaan dan mengurangi erosi (meningkatkan Faktor P).",
                mitigationItem3: "<b>Pola Tanam Kontur:</b> Menanam sejajar dengan garis kontur untuk menahan air dan tanah.",
                mitigationItem4: "<b>Penyuluhan kepada Masyarakat:</b> Edukasi mengenai praktik pertanian berkelanjutan untuk mengurangi erosi tanah.",
                mitigationFigcaption: "Tindakan konservasi di hulu adalah kunci keberlanjutan waduk.",
                referencesTitle: "Daftar Pustaka",
                footerDesigned: 'Designed by <a href="https://id.linkedin.com/in/mokhamadabrar" target="_blank" rel="noopener" class="text-amber-400 hover:underline">Mokhamad Abrar</a>',
                footerReviewed: 'Reviewed by <a href="https://id.linkedin.com/in/avior-qhse" target="_blank" rel="noopener" class="text-amber-400 hover:underline">Ratu Avior, MSc.</a> and <a href="https://id.linkedin.com/in/raniannisaroyani" target="_blank" rel="noopener noreferrer" class="text-amber-400 hover:underline">Ir. Rani A. Royani, MSc.</a>',
                footerDate: "Sustainable Apps Development @ Aug 2025",
                alertFull: "Simulasi berhenti: Cekungan sedimentasi sudah penuh.",
                mapTitle: "Peta Lokasi & Estimasi Tingkat Erosi DAS",
                helpReservoirTitle: "Bantuan: Parameter Dasar Waduk",
                helpReservoirContent: `<p>Parameter ini mendefinisikan karakteristik fundamental dari waduk dan DAS-nya, yang digunakan sebagai dasar perhitungan erosi dan umur waduk.</p>
                                       <ul>
                                           <li><b>Curah Hujan Tahunan:</b> Berpengaruh langsung pada Faktor Erosivitas Hujan (R). Curah hujan yang lebih tinggi umumnya menyebabkan potensi erosi yang lebih besar.</li>
                                           <li><b>Luas DAS:</b> Total area lahan yang mengalirkan air dan sedimen ke dalam waduk. Area yang lebih luas berarti potensi total erosi yang lebih besar.</li>
                                           <li><b>Total Volume Tampungan Sedimen:</b> Kapasitas maksimum waduk untuk menampung sedimen. Nilai ini, dikombinasikan dengan laju sedimentasi tahunan, menentukan umur pakai waduk.</li>
                                       </ul>`,
                helpRusleTitle: "Bantuan: Parameter RUSLE",
                helpRusleContent: `<p>Parameter ini adalah inti dari model RUSLE. Sesuaikan nilai-nilai ini untuk menyimulasikan berbagai skenario pengelolaan lahan dan konservasi.</p>
                                   <ul>
                                       <li><b>R (Erosivitas Hujan):</b> Dihitung otomatis dari Curah Hujan Tahunan. Merepresentasikan potensi hujan untuk menyebabkan erosi.</li>
                                       <li><b>K (Erodibilitas Tanah):</b> Resistansi inheren tanah terhadap erosi. Tanah liat memiliki nilai K rendah, sedangkan tanah lanau (silt) memiliki nilai K tinggi.</li>
                                       <li><b>LS (Panjang & Kemiringan Lereng):</b> Merepresentasikan topografi. Lereng yang lebih panjang dan curam menghasilkan laju erosi yang lebih tinggi.</li>
                                       <li><b>C (Pengelolaan Tanaman):</b> Merepresentasikan tutupan lahan. Nilai rendah mengindikasikan vegetasi padat (seperti hutan), sementara nilai tinggi mengindikasikan lahan gundul. <b>Ini adalah faktor kunci untuk mitigasi.</b></li>
                                       <li><b>P (Tindakan Konservasi):</b> Merepresentasikan praktik konservasi seperti terasering atau penanaman kontur. Nilai 1 berarti tidak ada praktik konservasi, sementara nilai yang lebih rendah menunjukkan konservasi yang efektif. <b>Ini adalah faktor kunci untuk mitigasi.</b></li>
                                   </ul>`
            }
        };

        // Fundamental Parameters (Default values based on Saguling case)
        const defaultParams = {
            annualRainfall: 3175, // mm
            watershedArea: 55700, // Ha
            reservoirVolume: 40.3, // million m³
            rusle: {
                R: { value: 1500, min: 500, max: 4000, label: 'R', descKey: 'rusleFactorR' },
                K: { value: 0.28, min: 0.05, max: 0.6, step: 0.01, label: 'K', descKey: 'rusleFactorK' },
                LS: { value: 15, min: 1, max: 50, label: 'LS', descKey: 'rusleFactorLS' },
                C: { value: 0.15, min: 0.001, max: 1, step: 0.001, label: 'C', descKey: 'rusleFactorC' },
                P: { value: 0.8, min: 0.1, max: 1, step: 0.01, label: 'P', descKey: 'rusleFactorP' }
            }
        };
        
        let currentParams = JSON.parse(JSON.stringify(defaultParams));
        
        function updateStartStopButtonText() {
            if (!isRunning) {
                startStopBtn.innerHTML = (day > 0) ? translations[currentLanguage].continueBtn : translations[currentLanguage].startBtn;
            } else {
                startStopBtn.innerHTML = translations[currentLanguage].pauseBtn;
            }
        }
        
        function updateRusleParamDescriptions() {
            for (const key in defaultParams.rusle) {
                const param = defaultParams.rusle[key];
                const labelElement = document.querySelector(`label[for="slider-${key}"]`);
                if (labelElement) {
                    labelElement.title = translations[currentLanguage][param.descKey] || '';
                }
            }
        }

        function setupRusleControls() {
            const container = document.getElementById('rusle-controls');
            container.innerHTML = '';
            for (const key in currentParams.rusle) {
                const param = currentParams.rusle[key];
                const sliderId = `slider-${key}`;
                const valueId = `value-${key}`;
                const isFactorR = key === 'R';

                const controlHTML = `
                    <div class="rusle-control-item">
                        <label for="${sliderId}" class="flex justify-between text-sm font-medium text-gray-400">
                            <span>${param.label}</span>
                            <span id="${valueId}">${param.value}</span>
                        </label>
                        <input type="range" id="${sliderId}" min="${param.min}" max="${param.max}" value="${param.value}" 
                               step="${param.step || 1}" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer rusle-slider"
                               ${isFactorR ? 'disabled' : ''}>
                    </div>
                `;
                container.innerHTML += controlHTML;
            }

            updateRusleParamDescriptions();

            for (const key in currentParams.rusle) {
                 if (key !== 'R') {
                    const slider = document.getElementById(`slider-${key}`);
                    slider.addEventListener('input', (e) => {
                        const valueEl = document.getElementById(`value-${key}`);
                        currentParams.rusle[key].value = parseFloat(e.target.value);
                        valueEl.textContent = parseFloat(e.target.value).toFixed(key === 'C' ? 3 : 2);
                        calculateEstimatedLife();
                        if(!isRunning) drawLandscape(); // Redraw static landscape
                    });
                }
            }
        }

        function setupClouds() {
            clouds = [];
            const numClouds = 3;
            for (let i = 0; i < numClouds; i++) {
                clouds.push({
                    x: (canvas.width / numClouds) * i + Math.random() * 50 - 25,
                    y: canvas.height * 0.15 + (Math.random() - 0.5) * 20,
                    radius: Math.random() * 20 + 35,
                    speed: Math.random() * 0.1 + 0.05
                });
            }
        }

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = Math.max(container.clientHeight, 350); 
        }

        function drawLightning() {
            if (lightning.alpha <= 0) return;
            ctx.fillStyle = `rgba(251, 191, 36, ${lightning.alpha * 0.5})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = `rgba(253, 224, 71, ${lightning.alpha})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(lightning.path[0].x, lightning.path[0].y);
            for (let i = 1; i < lightning.path.length; i++) {
                ctx.lineTo(lightning.path[i].x, lightning.path[i].y);
            }
            ctx.stroke();
            lightning.alpha -= 0.05;
        }

        function drawClouds() {
            clouds.forEach(cloud => {
                cloud.x += cloud.speed;
                if (cloud.x - cloud.radius > canvas.width) cloud.x = -cloud.radius * 2;
                ctx.fillStyle = 'rgba(113, 128, 150, 0.8)';
                ctx.beginPath();
                ctx.arc(cloud.x, cloud.y, cloud.radius * 0.6, 0, Math.PI * 2);
                ctx.arc(cloud.x + cloud.radius * 0.4, cloud.y + cloud.radius * 0.2, cloud.radius * 0.7, 0, Math.PI * 2);
                ctx.arc(cloud.x - cloud.radius * 0.5, cloud.y + cloud.radius * 0.1, cloud.radius * 0.5, 0, Math.PI * 2);
                ctx.closePath();
                ctx.fill();
            });
        }
        
        function getHillY(x, p0, p1, p2) {
             const t = x / p2.x;
             if (t < 0 || t > 1) return canvas.height;
             return Math.pow(1 - t, 2) * p0.y + 2 * (1 - t) * t * p1.y + Math.pow(t, 2) * p2.y;
        }

        function drawConservationVisuals(p0, p1, p2) {
            // Visualize Factor P (Terraces)
            const pValue = currentParams.rusle.P.value;
            const numTerraces = Math.floor(10 * (1 - pValue));
            if (numTerraces > 1) {
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
                ctx.lineWidth = 2;
                for (let i = 1; i <= numTerraces; i++) {
                    const terraceY = p0.y + (p2.y - p0.y) * (i / (numTerraces + 1));
                    ctx.beginPath();
                    let started = false;
                    for (let x = 0; x < p2.x; x++) {
                        const hillY = getHillY(x, p0, p1, p2);
                        if (Math.abs(hillY - terraceY) < 1) {
                           if (!started) { ctx.moveTo(x, hillY); started = true; } 
                           else { ctx.lineTo(x, hillY); }
                        }
                    }
                    ctx.stroke();
                }
            }
            
            // Visualize Factor C (Vegetation)
            const cValue = currentParams.rusle.C.value;
            const vegetationDensity = Math.floor(150 * (1 - cValue));
            ctx.fillStyle = 'rgba(34, 197, 94, 0.2)'; // Green
            for(let i = 0; i < vegetationDensity; i++) {
                const x = Math.random() * p2.x * 0.9;
                const y = getHillY(x, p0, p1, p2);
                const size = Math.random() * 4 + 2;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawLandscape() {
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGradient.addColorStop(0, '#2d3748'); skyGradient.addColorStop(1, '#4a5568');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawLightning();
            drawClouds();

            const damWidth = canvas.width * 0.1, damX = canvas.width - damWidth;
            const waterLevelY = canvas.height * 0.6, basinBottomY = canvas.height * 0.95;
            const p0 = { x: 0, y: canvas.height * 0.3 };
            const p1 = { x: canvas.width * 0.2, y: canvas.height * 0.4 };
            const p2 = { x: canvas.width * 0.6, y: basinBottomY };

            const hillColor = `rgb(${100 - soilSaturation * 0.5}, ${70 - soilSaturation * 0.4}, ${30 - soilSaturation * 0.2})`;
            const waterColor = '#2c5282', damColor = '#4a5568', sedimentColor = '#78350f';

            ctx.fillStyle = hillColor;
            ctx.beginPath();
            ctx.moveTo(p0.x, p0.y);
            ctx.quadraticCurveTo(p1.x, p1.y, p2.x, p2.y);
            ctx.lineTo(damX, basinBottomY);
            ctx.lineTo(damX, waterLevelY - 10);
            ctx.lineTo(canvas.width, waterLevelY - 20);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            ctx.fill();

            drawConservationVisuals(p0, p1, p2);

            const sedimentPercentage = totalSediment / (currentParams.reservoirVolume * 1e6);
            const maxSedimentHeight = basinBottomY - waterLevelY;
            const currentSedimentHeight = maxSedimentHeight * sedimentPercentage;
            
            if (currentSedimentHeight > 0) {
                ctx.fillStyle = sedimentColor;
                ctx.beginPath();
                ctx.moveTo(p2.x, basinBottomY);
                ctx.lineTo(damX, basinBottomY);
                ctx.lineTo(damX, basinBottomY - currentSedimentHeight);
                ctx.quadraticCurveTo(damX * 0.9, basinBottomY - currentSedimentHeight, p2.x, basinBottomY - currentSedimentHeight * 0.8);
                ctx.closePath();
                ctx.fill();
            }

            ctx.fillStyle = waterColor; ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.moveTo(p2.x, basinBottomY - currentSedimentHeight * 0.8);
            ctx.quadraticCurveTo(damX * 0.9, basinBottomY - currentSedimentHeight, damX, basinBottomY - currentSedimentHeight);
            ctx.lineTo(damX, waterLevelY);
            ctx.lineTo(0, waterLevelY * 1.1);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 1.0;
            
            ctx.fillStyle = damColor;
            ctx.beginPath();
            ctx.moveTo(damX, basinBottomY);
            ctx.lineTo(damX, waterLevelY - 10);
            ctx.lineTo(canvas.width, waterLevelY - 20);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(damX, canvas.height);
            ctx.closePath();
            ctx.fill();
        }

        function createSplash(x, y) {
            for (let i = 0; i < 3; i++) {
                splashParticles.push({
                    x: x, y: y, vx: (Math.random() - 0.5) * 2, vy: -Math.random() * 1.5,
                    radius: Math.random() * 1 + 0.5, alpha: 1
                });
            }
        }

        function createParticles() {
            if (isRaining && clouds.length > 0) {
                for (let i = 0; i < 5; i++) {
                    const cloud = clouds[Math.floor(Math.random() * clouds.length)];
                    rainParticles.push({
                        x: cloud.x + (Math.random() - 0.5) * cloud.radius,
                        y: cloud.y + cloud.radius * 0.3,
                        length: Math.random() * 20 + 10, speed: Math.random() * 5 + 5
                    });
                }
            } else if (daysOfSun > 0) {
                 for (let i = 0; i < 1; i++) {
                    evaporationParticles.push({
                        x: canvas.width * (0.5 + Math.random() * 0.4), y: canvas.height * 0.6,
                        radius: Math.random() * 2 + 1, speed: Math.random() * 0.5 + 0.2, alpha: 1
                    });
                }
            }
        }

        function updateAndDrawParticles() {
            const p0 = { x: 0, y: canvas.height * 0.3 };
            const p1 = { x: canvas.width * 0.2, y: canvas.height * 0.4 };
            const p2 = { x: canvas.width * 0.6, y: canvas.height * 0.95 };
            
            ctx.strokeStyle = 'rgba(160, 174, 192, 0.7)'; ctx.lineWidth = 2; 
            rainParticles.forEach((p, index) => {
                p.y += p.speed;
                const groundY = getHillY(p.x, p0, p1, p2);
                ctx.beginPath(); ctx.moveTo(p.x, p.y);
                const endY = Math.min(p.y + p.length, groundY);
                ctx.lineTo(p.x, endY); ctx.stroke();
                if (p.y >= groundY) {
                    createSplash(p.x, groundY);
                    rainParticles.splice(index, 1);
                }
            });

            ctx.fillStyle = 'rgba(160, 174, 192, 0.7)';
            splashParticles.forEach((p, index) => {
                p.x += p.vx; p.y += p.vy; p.vy += 0.1; p.alpha -= 0.04;
                ctx.globalAlpha = p.alpha;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1.0;
                if (p.alpha <= 0) { splashParticles.splice(index, 1); }
            });

            ctx.fillStyle = 'rgba(204, 137, 51, 0.7)';
            runoffParticles.forEach((p, index) => {
                p.x += p.vx; p.y += p.vy; p.vy += 0.1; 
                const groundY = getHillY(p.x, p0, p1, p2);
                if (p.y >= groundY) { p.y = groundY; p.vx = 2; }
                ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill();
                if (p.x > canvas.width * 0.6) { runoffParticles.splice(index, 1); }
            });
            
            evaporationParticles.forEach((p, index) => {
                p.y -= p.speed; p.alpha -= 0.01;
                ctx.fillStyle = `rgba(200, 210, 225, ${p.alpha})`;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill();
                if(p.alpha <= 0){ evaporationParticles.splice(index, 1); }
            });
        }

        function triggerLightning() {
            if (clouds.length === 0) return;
            const cloud = clouds[Math.floor(Math.random() * clouds.length)];
            const p0 = { x: 0, y: canvas.height * 0.3 }, p1 = { x: canvas.width * 0.2, y: canvas.height * 0.4 }, p2 = { x: canvas.width * 0.6, y: canvas.height * 0.95 };
            lightning.path = [];
            let currentPoint = { x: cloud.x, y: cloud.y + cloud.radius * 0.3 };
            lightning.path.push(currentPoint);
            let targetY = getHillY(cloud.x, p0, p1, p2);
            while (currentPoint.y < targetY) {
                let nextX = currentPoint.x + (Math.random() - 0.5) * 20;
                let nextY = currentPoint.y + Math.random() * 20 + 10;
                if (nextY > targetY) nextY = targetY;
                currentPoint = { x: nextX, y: nextY };
                lightning.path.push(currentPoint);
            }
            lightning.alpha = 1;
        }
        
        function calculateErosion() {
            const { R, K, LS, C, P } = currentParams.rusle;
            const annualErosionPerHa = R.value * K.value * LS.value * C.value * P.value;
            const totalAnnualErosion = annualErosionPerHa * currentParams.watershedArea;
            return totalAnnualErosion / 365;
        }
        
        function calculateEstimatedLife() {
            currentParams.annualRainfall = parseFloat(annualRainfallInput.value) || 0;
            currentParams.watershedArea = parseFloat(watershedAreaInput.value) || 0;
            currentParams.reservoirVolume = parseFloat(reservoirVolumeInput.value) || 0;
            const dailyErosionTon = calculateErosion();
            const totalAnnualErosionTon = dailyErosionTon * 365;
            const SDR = 0.2, bulkDensity = 1.4;
            const annualSedimentVolume = (totalAnnualErosionTon * SDR) / bulkDensity;
            const reservoirCapacityM3 = currentParams.reservoirVolume * 1e6;
            if (annualSedimentVolume > 0 && reservoirCapacityM3 > 0) {
                const years = reservoirCapacityM3 / annualSedimentVolume;
                estimatedLifeEl.textContent = `${years.toFixed(1)}`;
            } else {
                estimatedLifeEl.textContent = "∞";
            }
             return { dailyErosionTon, annualSedimentVolume };
        }

        function updateSimulationState() {
            if (isRaining) {
                daysOfRain++;
                if (daysOfRain >= maxRainDays) { isRaining = false; daysOfSun = 0; rainParticles = []; }
                if (Math.random() < 0.01 && lightning.alpha <= 0) { triggerLightning(); }
            } else {
                daysOfSun++;
                if (daysOfSun >= maxSunDays) { isRaining = true; daysOfRain = 0; evaporationParticles = []; }
            }
            if (isRaining) { soilSaturation = Math.min(100, soilSaturation + 5); } 
            else { soilSaturation = Math.max(0, soilSaturation - 2); }
            let dailyErosion = 0;
            if (isRaining && soilSaturation >= 100) {
                 const calcs = calculateEstimatedLife();
                 dailyErosion = calcs.dailyErosionTon;
                 totalErosion += dailyErosion;
                 const dailySedimentVolume = calcs.annualSedimentVolume / 365;
                 totalSediment += dailySedimentVolume;
                 const numParticles = Math.min(Math.ceil(dailyErosion / 5000), 20);
                 for(let i = 0; i < numParticles; i++) {
                     const startX = Math.random() * canvas.width * 0.5;
                     const p0 = { x: 0, y: canvas.height * 0.3 }, p1 = { x: canvas.width * 0.2, y: canvas.height * 0.4 }, p2 = { x: canvas.width * 0.6, y: canvas.height * 0.95 };
                     runoffParticles.push({
                         x: startX, y: getHillY(startX, p0, p1, p2), radius: Math.random() * 2 + 1.5, vx: 1, vy: 1
                     });
                 }
            }
            day++;
            dayCountEl.textContent = day;
            dailyErosionEl.textContent = dailyErosion.toFixed(2);
            totalErosionEl.textContent = totalErosion.toFixed(2);
            soilSaturationEl.textContent = Math.round(soilSaturation);
            const sedimentPercentage = (totalSediment / (currentParams.reservoirVolume * 1e6)) * 100;
            sedimentationLevelEl.textContent = sedimentPercentage.toFixed(2);
            
            simulationLog.push({
                day: day,
                dailyErosion: dailyErosion.toFixed(2),
                totalErosion: totalErosion.toFixed(2),
                soilSaturation: Math.round(soilSaturation),
                sedimentationLevel: sedimentPercentage.toFixed(2)
            });
            updateMapData();

            if(sedimentPercentage >= 100){
                stopSimulation();
                alert(translations[currentLanguage].alertFull);
            }
        }
        
        function gameLoop() {
            if (!isRunning) return;
            updateSimulationState();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawLandscape();
            createParticles();
            updateAndDrawParticles();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function startSimulation() {
            if (isRunning) return;
            isRunning = true;
            updateStartStopButtonText();
            startStopBtn.classList.remove('from-amber-400', 'to-amber-600');
            startStopBtn.classList.add('from-yellow-400', 'to-yellow-600');
            gameLoop();
        }

        function stopSimulation() {
            if (!isRunning) return;
            isRunning = false;
            updateStartStopButtonText();
            startStopBtn.classList.remove('from-yellow-400', 'to-yellow-600');
            startStopBtn.classList.add('from-amber-400', 'to-amber-600');
            cancelAnimationFrame(animationFrameId);
        }
        
        function resetSimulationState() {
            day = 0; soilSaturation = 0; totalErosion = 0; totalSediment = 0;
            isRaining = true; daysOfRain = 0; daysOfSun = 0;
            rainParticles = []; runoffParticles = []; evaporationParticles = []; splashParticles = [];
            lightning.alpha = 0; simulationLog = [];
            dayCountEl.textContent = '0'; dailyErosionEl.textContent = '0.00';
            totalErosionEl.textContent = '0.00'; soilSaturationEl.textContent = '0';
            sedimentationLevelEl.textContent = '0.00';
            resetMapData();
            drawLandscape();
        }
        
        function fullResetToDefaults() {
            stopSimulation();
            updateStartStopButtonText();
            startStopBtn.classList.remove('from-yellow-400', 'to-yellow-600');
            startStopBtn.classList.add('from-amber-400', 'to-amber-600');
            currentParams = JSON.parse(JSON.stringify(defaultParams));
            annualRainfallInput.value = defaultParams.annualRainfall;
            watershedAreaInput.value = defaultParams.watershedArea;
            reservoirVolumeInput.value = defaultParams.reservoirVolume;
            for (const key in currentParams.rusle) {
                const slider = document.getElementById(`slider-${key}`);
                const valueEl = document.getElementById(`value-${key}`);
                if (slider) { slider.value = currentParams.rusle[key].value; }
                if (valueEl) { valueEl.textContent = slider.value; }
            }
            updateMapWithGeoJSON(defaultWatershedGeoJson, "DAS Citarum");
        }
        
        function applyParamsAndReset() {
            const newR = (parseFloat(annualRainfallInput.value) || 0) * 0.5;
            currentParams.rusle.R.value = newR;
            const rValueEl = document.getElementById('value-R');
            const rSliderEl = document.getElementById('slider-R');
            if(rValueEl && rSliderEl){
                rValueEl.textContent = newR.toFixed(0);
                rSliderEl.value = newR;
            }
            calculateEstimatedLife();
            resetSimulationState();
        }

        function setLanguage(lang) {
            currentLanguage = lang;
            document.documentElement.lang = lang;
            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.dataset.langKey;
                if (translations[lang][key]) {
                    el.innerHTML = translations[lang][key];
                }
            });
            langIdBtn.classList.toggle('active', lang === 'id');
            langEnBtn.classList.toggle('active', lang === 'en');
            updateRusleParamDescriptions();
            updateStartStopButtonText();
        }

        function updateRusleParamDescriptions() {
            for (const key in defaultParams.rusle) {
                const param = defaultParams.rusle[key];
                const labelElement = document.querySelector(`label[for="slider-${key}"]`);
                if (labelElement) {
                    labelElement.title = translations[currentLanguage][param.descKey] || '';
                }
            }
        }
        
        function updateStartStopButtonText() {
            if (!isRunning) {
                startStopBtn.innerHTML = (day > 0) ? translations[currentLanguage].continueBtn : translations[currentLanguage].startBtn;
            } else {
                startStopBtn.innerHTML = translations[currentLanguage].pauseBtn;
            }
        }
        
        function showHelpModal(topic) {
            if (topic === 'reservoirParams') {
                helpModalTitle.innerHTML = translations[currentLanguage].helpReservoirTitle;
                helpModalContent.innerHTML = translations[currentLanguage].helpReservoirContent;
            } else if (topic === 'rusleParams') {
                helpModalTitle.innerHTML = translations[currentLanguage].helpRusleTitle;
                helpModalContent.innerHTML = translations[currentLanguage].helpRusleContent;
            }
            helpModal.classList.remove('hidden');
            helpModal.classList.add('flex');
        }

        function hideHelpModal() {
            helpModal.classList.add('hidden');
            helpModal.classList.remove('flex');
        }

        // --- Map Functions ---
        const defaultWatershedGeoJson = {
            "type": "Feature", "properties": { "name": "DAS Citarum" },
            "geometry": { "type": "Polygon", "coordinates": [
                [
                    [107.476, -7.253], [107.728, -7.348], [107.910, -7.202],
                    [107.989, -7.025], [107.882, -6.840], [107.781, -6.721],
                    [107.808, -6.591], [107.641, -6.501], [107.420, -6.495],
                    [107.240, -6.529], [107.098, -6.671], [107.062, -6.842],
                    [107.218, -6.994], [107.351, -7.159], [107.476, -7.253]
                ]
            ]}
        };

        function getErosionColor(erosionTon) {
            const annualErosion = erosionTon * (365/day) || 0;
            // Adjusted thresholds for better color scaling based on expected values
            if (annualErosion > 10000000) return '#ef4444'; // red-500 for very high erosion
            if (annualErosion > 2000000) return '#f59e0b'; // amber-500 for high erosion
            return '#22c55e'; // green-500 for low/moderate erosion
        }
        
        function calculatePolygonArea(latlngs) {
            if (!latlngs || latlngs.length < 3) return 0;
            let area = 0;
            const earthRadius = 6378137; // meters
            for (let i = 0; i < latlngs.length; i++) {
                let p1 = latlngs[i];
                let p2 = latlngs[(i + 1) % latlngs.length];
                area += (p2[1] * Math.PI / 180 - p1[1] * Math.PI / 180) *
                        (2 + Math.sin(p1[0] * Math.PI / 180) + Math.sin(p2[0] * Math.PI / 180));
            }
            return Math.abs(area * earthRadius * earthRadius / 2.0);
        }

        function updateMapWithGeoJSON(geoJSON, fileName) {
            if (watershedLayer) map.removeLayer(watershedLayer);
            if (assessmentMarker) map.removeLayer(assessmentMarker);
            
            geoJSON.properties.name = fileName.replace('.csv', '');
            currentWatershedGeoJson = geoJSON;

            const style = {
                color: "#f59e0b", weight: 2, opacity: 0.9,
                fillOpacity: 0.3, fillColor: getErosionColor(0)
            };

            watershedLayer = L.geoJSON(geoJSON, { style: style }).addTo(map);
            map.fitBounds(watershedLayer.getBounds());

            const center = watershedLayer.getBounds().getCenter();
            assessmentMarker = L.marker(center, { draggable: true }).addTo(map)
                .bindPopup("Titik Asesmen (Dapat Digeser)").openPopup();
            
            const latLngsForArea = geoJSON.geometry.coordinates[0].map(c => [c[1], c[0]]); // [[lat, lon]]
            const areaM2 = calculatePolygonArea(latLngsForArea);
            const areaHa = areaM2 / 10000;
            watershedAreaInput.value = areaHa.toFixed(2);
            applyParamsAndReset();
        }

        function parseCSVToGeoJSON(csvText, fileName) {
            try {
                const lines = csvText.trim().split('\n');
                const coordinates = [];
                for (const line of lines) {
                    const parts = line.split(',');
                    if (parts.length >= 2) {
                        const lat = parseFloat(parts[0].trim().replace(/"/g, ''));
                        const lon = parseFloat(parts[1].trim().replace(/"/g, ''));
                        if (!isNaN(lat) && !isNaN(lon)) {
                            coordinates.push([lon, lat]); // GeoJSON format is [lon, lat]
                        }
                    }
                }
                if (coordinates.length < 3) throw new Error("Data CSV tidak cukup untuk membentuk poligon.");
                
                // Close the polygon loop if it's not closed
                if (coordinates[0][0] !== coordinates[coordinates.length - 1][0] || coordinates[0][1] !== coordinates[coordinates.length - 1][1]) {
                    coordinates.push(coordinates[0]);
                }

                return {
                    "type": "Feature", "properties": { "name": fileName },
                    "geometry": { "type": "Polygon", "coordinates": [coordinates] }
                };
            } catch (error) {
                alert("Gagal memproses file CSV. Pastikan formatnya benar (latitude, longitude) dan tidak ada header. Error: " + error.message);
                return null;
            }
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const geoJSON = parseCSVToGeoJSON(e.target.result, file.name);
                if (geoJSON) {
                    updateMapWithGeoJSON(geoJSON, file.name);
                }
            };
            reader.readAsText(file);
        }

        function initMap() {
            map = L.map('map').setView([-6.92, 107.52], 9);
            
            const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles &copy; Esri'
            });

            const topo = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                attribution: 'Map data: &copy; OpenStreetMap contributors, SRTM | &copy; OpenTopoMap'
            });

            satellite.addTo(map);

            const baseMaps = {"Satelit": satellite, "Topografi": topo};

            updateMapWithGeoJSON(defaultWatershedGeoJson, "DAS Citarum");
            L.control.layers(baseMaps, { "Batas DAS": watershedLayer }).addTo(map);
        }
        
        function updateMapData(){
            if (!watershedLayer || !currentWatershedGeoJson) return;
            const color = getErosionColor(totalErosion);
            watershedLayer.setStyle({ fillColor: color });
            
            const popupContent = `<b>${currentWatershedGeoJson.properties.name}</b><br>Estimasi Akumulasi Erosi:<br>${totalErosion.toFixed(2)} ton`;
            watershedLayer.bindPopup(popupContent);
        }
        
        function resetMapData(){
            if (!watershedLayer || !currentWatershedGeoJson) return;
            watershedLayer.setStyle({ fillColor: getErosionColor(0) });
            const popupContent = `<b>${currentWatershedGeoJson.properties.name}</b><br>Estimasi Akumulasi Erosi:<br>0.00 ton`;
            watershedLayer.bindPopup(popupContent);
        }

        // --- Event Listeners ---
        startStopBtn.addEventListener('click', () => {
            if(isRunning) { stopSimulation(); } else { startSimulation(); }
        });
        resetBtn.addEventListener('click', fullResetToDefaults);
        csvFileInput.addEventListener('change', handleFileUpload);
        window.addEventListener('resize', () => { resizeCanvas(); setupClouds(); drawLandscape(); });
        [annualRainfallInput, watershedAreaInput, reservoirVolumeInput].forEach(input => {
            input.addEventListener('input', () => { if(isRunning) stopSimulation(); applyParamsAndReset(); });
        });
        langIdBtn.addEventListener('click', () => setLanguage('id'));
        langEnBtn.addEventListener('click', () => setLanguage('en'));
        document.querySelectorAll('.help-icon').forEach(icon => {
            icon.addEventListener('click', (e) => {
                showHelpModal(e.target.dataset.helpTopic);
            });
        });
        closeHelpModalBtn.addEventListener('click', hideHelpModal);
        helpModal.addEventListener('click', (e) => {
            if (e.target === helpModal) hideHelpModal(); // Close on overlay click
        });


        // --- Initial Setup ---
        function init() {
            setupRusleControls();
            resizeCanvas();
            setupClouds();
            initMap();
            applyParamsAndReset();
            setLanguage('id');
        }

        init();
    </script>
</body>
</html>

